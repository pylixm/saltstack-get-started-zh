# 事件驱动基础

如果您完成了以前的指南，您已经学会了如何使用Salt在远程系统上执行命令，以及如何定义可重用的模板来配置系统。

大多数配置工具也就这些功能了（什么还远没有这些），但是对于Salt，这些功能只是一半的功能。

## 底层事件驱动

Salt是围绕事件基础架构构建，可以利用和扩展，以便在基础架构中的所有设备上驱动无故障配置，配置和管理。

本节将会向你介绍Salt 的时间驱动系统和如何完成以下内容的：

- 监控并启动 Salt 事件
- 监控非 Salt 活动
- 基于事件的目标触发器

## 监听事件

Salt的内部组件通过发送和收听事件相互通信。

在 Salt 内部，事件发送和你可以想象到的任何事情有关：

- Salt minion 的链接
- key 的接受和拒绝
- job 的发送
- job 的返回
- 心跳检测

即使Salt命令行界面也使用事件系统。命令发送给Salt master后，Salt CLI只需从事目标minion手中 检测任务的返回即可。

Salt提供了一个`Runner`模块，可以在Salt master上收到实时显示事件。
```bash
salt-run state.event pretty=True
```

如果您正在使用演示环境，您的事件总线可能很安静，因此打开另一个终端并发送salt'*'test.ping命令，或者在您的其中一个终端上重新启动salt-minion服务。
以下是几个类似于您在Salt主页上看到的事件：
```json
salt/job/20150923203228234305/new   {
    "_stamp": "2015-09-23T20:32:28.235712",
    "arg": [],
    "fun": "test.ping",
    "jid": "20150923203228234305",
    "minions": [
        "minion2"
    ],
    "tgt": "*",
    "tgt_type": "glob",
    "user": "sudo_vagrant"
}
salt/job/20150923203228234305/ret/minion2   {
    "_stamp": "2015-09-23T20:32:28.291789",
    "cmd": "_return",
    "fun": "test.ping",
    "fun_args": [],
    "id": "minion2",
    "jid": "20150923203228234305",
    "retcode": 0,
    "return": true,
    "success": true
}
salt/auth   {
    "_stamp": "2015-09-23T20:30:02.998305",
    "act": "pend",
    "id": "minion1",
    "pub": "-----BEGIN PUBLIC KEY-----\...\n-----END PUBLIC KEY-----\n",
    "result": true
}
```

### 事件格式

事件由两个主要部分组成：用于标识被触发的事件的标签以及包含事件详细信息的数据。

### 事件标签

所有Salt 事件都以`salt/`为前缀，其他级别根据事件类型而定。例如，job 事件以`salt/job/` 为前缀。使用/分隔每个事件部分以提供简单的命名空间。这些标识符称为事件标签，并且通常包含特定详细信息，例如作业ID或小数位数。

除了事件标签，每个事件还包括特定的事件数据。

### 事件数据

每个事件都包含一个时间戳以及特定事件唯一的附加键和值。

稍后我们探索反应堆时，您将学习如何使用事件标签和数据来自定义反应。

## 自定义事件

除了内置事件之外，您还可以在Salt系统中启用一些其他事件，并生成自己的事件。

### 当前活动事件

启用在线状态会导致主机定期查找主动连接的端点设备。定期事件在事件总线上触发事件总线，其中列出了连接的分支机构，以及具有新连接或断开连接的minion列表的事件。
```
presence_events: True
```
### salt stats 事件



## 标识（BEACONS）

## 事件反应堆（EVENT REACTOR）